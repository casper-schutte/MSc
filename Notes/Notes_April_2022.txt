Notes from Prof:
    - Make a scoring scheme. For each read, see by how many bp it overhangs the reference.
        (incorrect assignment). Derive a "map quality" score for each read in this way.
        Think about the maths and come up with a coefficient or mapping score
        for the alignment of the read to the reference.


    - Think about choosing examiners (thinking about internal examiners).

    - Think about testing different alignment algorithms with the bash script



08/04/2022:
    - Cleaning up the git repo.
    - Moving away from testing the algorithm 100s of times with the bash script, will now try to clean up the
        outputs and take the data further by adding a scoring system.


22/04/22:
    - Have been thinking about aspects of the project, reading about the details of MAPQ and how it is calculated.
        - I can't simply use the sum of MAPQ values as a score, as it is not a linear function (logarithmic).
        - I need to learn more about the scores to figure out to what degree I can rely on them.

    - I need to change my script such that all the borders are returned, and keep the current version for testing.

    - Need to change the output and think about a way in which I can automate the testing.


What is a MAPQ score?: MAPing Quality
    - Definition: MAPQ = -10log(Pr{mapping position is wrong})
        - as defined in the SAM format documentation.
        - Thus, if you knew that the prob for a given read mapping correctly is 0.99,
            the MAPQ score would be 20. If the prob was 0.999, the MAPQ score would be 30.
            This means that there is no upper bound on MAPQ scores! It also means I should rethink
            my current MAPQ threshold, since a MAPQ of 40 means a prob of 0.9999 of mapping correctly.
        - This means that my results where some borders were not found should perhaps be repeated
            with a lower MAPQ threshold.
        - Another crucial point to consider, especially if I plan to repeat experiments with other
            BW-aligners, is that MAPQs cannot be directly compared between different software.

    IDEA: screw the cumulative score, if a read has a MAPQ of >40, its probability of mapping to that position is
        over 0.999! (non-factorial exclamation). Such a score would only need to come into play if there was
        uncertainty in the mapping position. Do not disregard this idea completely, it could be useful if I run
        into problems where duplications and repetitive regions throw a spanner in the works.


23/04/22:
    - Need to find a way to represent the uncertainty surrounding the exact positions of the breakpoints.
        - There is often disagreement between the reads that mapped initially and those that did not.
        - There might be a way to find the "true" or most certain of the two. The reads that did NOT map initially
            are probably the most certain ones. Think about this.

    - Think about the final output we want to return.
        - We want to know the positions of the borders between rearranged blocks.
        - We don't want to return SNPs though. This means I will have to add some sort of length-of-mismatch
            check in my code when it is looking at the CIGAR string. There is already code that extracts the
            CIGAR string to adjust the positions to reflect where the breakpoint is. I could ignore the reads
            where the CIGAR string shows a mismatch of only a few bp. This would eliminate the problem of SNPs and
            it shouldn't affect the assignment of legitimate borders.

        - I can introduce a single SNP somewhere in the test genome. It should show up as a "border" with the
            current script. I can then add a check in the script that omits reads with too many matches
            Pseudocode:
            if len(read) == 100 and (i)M > 95 or len(read) == 200 and (i)M > 195:
                pass
            else:
                keep read

            But make it work with any read length. Could use (i)M > len(read) - 5
            or some arbitrary threshold I decide on.


    Experiment 11: excluding SNPs.
        - Will first introduce an SNP into the rearranged genome.
            - NB: changing name of rearranged genome to ref_exp11.fa
        - SNP at pos 210 on Chr 2: C -> A

        - Running the pipeline as normal
            - Out of 3 tests, the SNP was found all 3 times. Once with 4 reads, twice with 2. All the reads had
                MAPQ scores of 44 (perfect score). All the reads had less than 5 bp soft-clipped. It seems that
                for reads where the SNP was in the middle were not mapped to the position. Possibly because of the
                sensitivity of the local alignment. This is good, it automatically removes some edge cases that
                I would have had to worry about.
            - The SNP will stay in the genome so that I can verify that it does not appear in further tests.
            - Will now attempt to remove it.



